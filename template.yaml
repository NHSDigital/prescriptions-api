AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  prescriptions api

# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst
Globals:
  Function:
    Timeout: 30
    MemorySize: 256

Parameters:
  EndpointUrl:
    Type: String
    Description: EndpointUrl
    Default: none

# Example of Mappings
# Mappings:
#   EnvVariables:
#     stage:
#         var1: user1
#         API_BASE_URL: https://baseurl1.com
#     prod:
#         var1: user2
#         API_BASE_URL: https://baseurl2.com

# SAM Connectors: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/reference-sam-connector.html
# https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-connector.html
# More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction
# More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api

Resources:
  # common KMS key for cloudwatch log groups
  CloudWatchKMSKey:
    Type: "AWS::KMS::Key"
    Properties:
      KeyPolicy:
        Version: 2012-10-17
        Id: key-policy-id
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: "kms:*"
            Resource: "*"
          - Effect: Allow
            Principal:
              Service: !Sub "logs.${AWS::Region}.amazonaws.com"
            Action:
              - kms:Encrypt*
              - kms:Decrypt*
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:Describe*
            Resource: "*"
            Condition:
              ArnEquals:
                kms:EncryptionContext:aws:logs:arn: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"

  CloudWatchKMSKeyAlias:
    Type: "AWS::KMS::Alias"
    Properties:
      AliasName: !Sub "alias/${AWS::StackName}-CloudWatchKMSAlias"
      TargetKeyId: !Ref CloudWatchKMSKey

  # Kinesis Splunk Firehose stuff
  SplunkDataStream:
    Type: "AWS::Kinesis::Stream"
    Properties:
      RetentionPeriodHours: 720 # 30 days of log retention
      StreamModeDetails:
        StreamMode: "ON_DEMAND"
        # Using on demand as provisioned + dev deployments would be expensive
        # May want to change for prod if needed
      StreamEncryption:
        EncryptionType: KMS
        KeyId: !GetAtt CloudWatchKMSKey.Arn
  SplunkSubscriptionFilterRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "logs.amazonaws.com"
            Action: "sts:AssumeRole"
  SplunkSubscriptionFilterDataStreamPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-put-data-stream-records"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - kinesis:PutRecord
              - kinesis:PutRecords
            Resource:
              - !GetAtt SplunkDataStream.Arn
      Roles:
        - !Ref SplunkSubscriptionFilterRole
  SplunkSubscriptionFilterKMSPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-kms-generate-data-key"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - kms:GenerateDataKey
            Resource:
              - !GetAtt CloudWatchKMSKey.Arn
      Roles:
        - !Ref SplunkSubscriptionFilterRole
  SplunkDeliveryStream:
    # Depends on policy as delivery streams require a role with correct policies to be build, and a role reference doesn't provide a dependency as Stream -> Role <- Policy, so Stream -!> Policy
    DependsOn:
      - SplunkDeliveryStreamDataStreamAccessPolicy
      - SplunkDeliveryStreamBackupBucketPolicy
      - SplunkDeliveryStreamDestinationBucketPolicy
    Type: AWS::KinesisFirehose::DeliveryStream
    Properties:
      DeliveryStreamType: KinesisStreamAsSource
      KinesisStreamSourceConfiguration:
        KinesisStreamARN: !GetAtt SplunkDataStream.Arn
        RoleARN: !GetAtt SplunkDeliveryStreamDataStreamAccessRole.Arn
      # Template SplunkDestinationConfiguration for when we get HEC information (Untested)
      # SplunkDestinationConfiguration:
      #   HECEndpoint: "" # TODO - Get HEC Endpoint info
      #   HECEndpointType: "Raw"/"Event" # TODO - Get HEC Endpoint type
      #   HECToken: "" # TODO - Get HEC Token
      #   ProcessingConfiguration:
      #     Enabled: true
      #     Processors:
      #       - Type: Lambda
      #         Parameters:
      #           - ParameterName: LambdaArn
      #             ParameterValue: !GetAtt SplunkDeliveryStreamProcessor.Arn
      #   S3Configuration:
      #     BucketARN: !GetAtt SplunkDeliveryStreamBackupBucket.Arn
      #     RoleARN: !GetAtt SplunkDeliveryStreamBackupBucketRole.Arn
      #     EncryptionConfiguration:
      #       KMSEncryptionConfig:
      #         AWSKMSKeyARN: !GetAtt CloudWatchKMSKey.Arn # TODO - Do we need a different KMS key for this?
      S3DestinationConfiguration:
        BucketARN: !GetAtt SplunkDeliveryStreamDestinationBucket.Arn
        RoleARN: !GetAtt SplunkDeliveryStreamDestinationBucketRole.Arn
  SplunkDeliveryStreamDataStreamAccessRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "firehose.amazonaws.com"
            Action: "sts:AssumeRole"
  SplunkDeliveryStreamDataStreamAccessPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-access-data-stream"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - kinesis:GetRecords
              - kinesis:DescribeStream
            Resource:
              - !GetAtt SplunkDataStream.Arn
      Roles:
        - !Ref SplunkDeliveryStreamDataStreamAccessRole
  SplunkDeliveryStreamBackupBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: false
            ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !GetAtt CloudWatchKMSKey.Arn # TODO - Do we need a different KMS key for this?
  SplunkDeliveryStreamBackupBucketRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "s3.amazonaws.com"
            Action: "sts:AssumeRole"
  SplunkDeliveryStreamBackupBucketPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-backup-bucket-access"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - s3:AbortMultipartUpload
              - s3:GetBucketLocation
              - s3:GetObject
              - s3:ListBucket
              - s3:ListBucketMultipartUploads
              - s3:PutObject
            Resource:
              - !GetAtt SplunkDeliveryStreamBackupBucket.Arn
              - !Join # Access to bucket contents
                - ""
                - - !GetAtt SplunkDeliveryStreamBackupBucket.Arn
                  - "/*"
      Roles:
        - !Ref SplunkDeliveryStreamBackupBucketRole
  SplunkDeliveryStreamProcessor:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: packages/splunkProcessor/src
      Handler: app.handler
      Runtime: nodejs18.x
      Role: !GetAtt SplunkDeliveryStreamProcessorRole.Arn
      Architectures:
        - x86_64
    Metadata: # Manage esbuild properties
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: "es2020"
        Sourcemap: true
        EntryPoints:
          - app.js
  # Bucket and Role for a data stream destination bucket used as a test until Splunk HEC information is found
  SplunkDeliveryStreamDestinationBucket:
    Type: AWS::S3::Bucket
  SplunkDeliveryStreamDestinationBucketRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "firehose.amazonaws.com"
            Action: "sts:AssumeRole"
  SplunkDeliveryStreamDestinationBucketPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-destination-bucket-access"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - s3:AbortMultipartUpload
              - s3:GetBucketLocation
              - s3:GetObject
              - s3:ListBucket
              - s3:ListBucketMultipartUploads
              - s3:PutObject
            Resource:
              - !GetAtt SplunkDeliveryStreamDestinationBucket.Arn
              - !Join # Access to bucket contents
                - ""
                - - !GetAtt SplunkDeliveryStreamDestinationBucket.Arn
                  - "/*"
      Roles:
        - !Ref SplunkDeliveryStreamDestinationBucketRole

  # Authz function stuff
  AuthzFunctionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
  AuthzFunctionLoggingPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-lambda-logging"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${AuthzFunctionLogGroup}"
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${AuthzFunctionLogGroup}:log-stream:*"
      Roles:
        - !Ref AuthzFunctionRole
  AuthzFunctionKMSPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-KMS-access"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - kms:DescribeKey
              - kms:GenerateDataKey*
              - kms:Encrypt
              - kms:ReEncrypt*
            Resource:
              - !GetAtt CloudWatchKMSKey.Arn
      Roles:
        - !Ref AuthzFunctionRole
  AuthzFunctionLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AuthzFunction}"
      RetentionInDays: 90
      KmsKeyId: !GetAtt CloudWatchKMSKey.Arn
  AuthzSplunkSubscriptionFilter:
    DependsOn:
      - SplunkSubscriptionFilterDataStreamPolicy
      - SplunkSubscriptionFilterKMSPolicy
    Type: "AWS::Logs::SubscriptionFilter"
    Properties:
      RoleArn: !GetAtt SplunkSubscriptionFilterRole.Arn
      LogGroupName: !Ref AuthzFunctionLogGroup
      Distribution: "Random"
      FilterPattern: " " # Replace as needed
      DestinationArn: !GetAtt SplunkDataStream.Arn
  AuthzFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: packages/authz/src
      Handler: app.handler
      Runtime: nodejs18.x
      Role: !GetAtt AuthzFunctionRole.Arn
      Architectures:
        - x86_64
      Environment:
        Variables:
          EndpointUrl: !Ref EndpointUrl
          NODE_OPTIONS: --enable-source-maps
      Events:
        authz:
          Type: Api
          Properties:
            Path: /authz
            Method: get
    Metadata: # Manage esbuild properties
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: "es2020"
        Sourcemap: true
        EntryPoints:
          - app.ts

  # getMyPrescription stuff
  GetMyPrescriptionsRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
  GetMyPrescriptionsLambdaPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-lambda-logging"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${GetMyPrescriptionsLogGroup}"
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${GetMyPrescriptionsLogGroup}:log-stream:*"
      Roles:
        - !Ref GetMyPrescriptionsRole
  GetMyPrescriptionsKMSPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: "allow-KMS-access"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - kms:DescribeKey
              - kms:GenerateDataKey*
              - kms:Encrypt
              - kms:ReEncrypt*
            Resource:
              - !GetAtt CloudWatchKMSKey.Arn
      Roles:
        - !Ref GetMyPrescriptionsRole
  GetMyPrescriptionsLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      LogGroupName: !Sub "/aws/lambda/${GetMyPrescriptions}"
      RetentionInDays: 90
      KmsKeyId: !GetAtt CloudWatchKMSKey.Arn
  GetMyPrescriptionsSplunkSubscriptionFilter:
    DependsOn:
      - SplunkSubscriptionFilterDataStreamPolicy
      - SplunkSubscriptionFilterKMSPolicy
    Type: "AWS::Logs::SubscriptionFilter"
    Properties:
      RoleArn: !GetAtt SplunkSubscriptionFilterRole.Arn
      LogGroupName: !Ref GetMyPrescriptionsLogGroup
      FilterPattern: " " # Replace as needed
      DestinationArn: !GetAtt SplunkDataStream.Arn
  GetMyPrescriptions:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: packages/getMyPrescriptions/src
      Handler: app.handler
      Runtime: nodejs18.x
      Role: !GetAtt GetMyPrescriptionsRole.Arn
      Architectures:
        - x86_64
      Environment:
        Variables:
          EndpointUrl: !Ref EndpointUrl
          NODE_OPTIONS: --enable-source-maps
      Events:
        authz:
          Type: Api
          Properties:
            Path: /getMyPrescriptions
            Method: get
            RequestParameters:
              - method.request.querystring.returnType:
                  Required: false
    Metadata: # Manage esbuild properties
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: "es2020"
        Sourcemap: true
        EntryPoints:
          - app.ts

Outputs:
  # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function
  # Find out more about other implicit resources you can reference within SAM
  # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api
  PrescriptionApi:
    Description: "API Gateway endpoint URL for Prod stage for the Main function"
    Value: !Sub "https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/"
  AuthzFunction:
    Description: "Authz Lambda Function ARN"
    Value: !GetAtt AuthzFunction.Arn
  AuthzFunctionIamRole:
    Description: "Implicit IAM Role created for the Authz function"
    Value: !GetAtt AuthzFunctionRole.Arn
  GetMyPrescriptionsFunction:
    Description: "GetMyPrescriptions Lambda Function ARN"
    Value: !GetAtt GetMyPrescriptions.Arn
  GetMyPrescriptionsFunctionIamRole:
    Description: "Implicit IAM Role created for the GetMyPrescriptions function"
    Value: !GetAtt GetMyPrescriptionsRole.Arn
